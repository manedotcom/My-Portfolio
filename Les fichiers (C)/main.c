#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <time.h>
#include <windows.h>
#include "headers.h"







int main() {
    int blockNumber;

/********** WELCOMING PAGE **********/

    const char *line1 = "   _____ ____    ____  _____ ____  ____  ";
    const char *line2 = "  |_   _|  _ \\  / ___||  ___/ ___||  _ \\ ";
    const char *line3 = "    | | | |_) | \\___ \\| |_  \\___ \\| | | | ";
    const char *line4 = "    | | |  __/   ___) |  _|  ___) | |_| | ";
    const char *line5 = "    |_| |_|     |____/|_|   |____/|____/  ";
    const char *line6 = "  _______  _______  _______  _   ___   /   _______  _______  _______  _______ ";
    const char *line7 = " |       ||  _    ||       || | |   |     |       ||  _    ||       ||       |";
    const char *line8 = " |____   || | |   ||____   || |_|   |     |____   || | |   ||____   ||   ____|";
    const char *line9 = "  ____|  || | |   | ____|  ||       |      ____|  || | |   | ____|  ||  |____ ";
    const char *line10 = " | ______|| |_|   || ______||___    |     | ______|| |_|   || ______||_____  |";
    const char *line11 = " | |_____ |       || |_____     |   |     | |_____ |       || |_____  _____| |";
    const char *line12 = " |_______||_______||_______|    |___|     |_______||_______||_______||_______|";
    system("cls");
    Textecolor(9);
        Sleep(1000);
printf("\n");
    printf("%s\n", line1);
    Sleep(100);
    printf("%s\n", line2);
    Sleep(100);
    printf("%s\n", line3);
    Sleep(100);
    printf("%s\n", line4);
    Sleep(100);
    printf("%s\n", line5);
    Sleep(100);
    Textecolor(2);
    printf("%s\n", line6);
    Sleep(100);
    printf("%s\n", line7);
    Sleep(100);
    printf("%s\n", line8);
    Sleep(100);
    printf("%s\n", line9);
    Sleep(100);
    printf("%s\n", line10);
    Sleep(100);
    printf("%s\n", line11);
    Sleep(100);
    printf("%s\n", line12);
            Textecolor(7);

    printf("\n\n\n\n");
    Textecolor(7);printf("             ttwzyyxxxwxxxyyxxr            txyyyxxwwxxyyyyvu       ");Textecolor(9);printf("XSSSSSSSSSSSSUW               \n"); usleep(100000);
    Textecolor(7);printf("          uxzzzzzzzzzzzzzzzzzzzzywv    uxzzzzzzzzzzzzzzzzzzzzzxt  ");Textecolor(9);printf("SSSSSSSSSSSSSSSU               \n"); usleep(100000);
    Textecolor(7);printf("         pyzzzzzzzzzyxwyzzzzzzzzzzy   xxzzzzzzzzzzxxyzzzzzzzzzzzt ");Textecolor(9);printf("RSSSSSSSSSSSSSST               \n"); usleep(100000);
    Textecolor(7);printf("         zzzzzzzzzzzxt  xzzzzzzzzzy   zzzzzzzzzzzwu  zzzzzzzzzzzz ");Textecolor(9);printf("TTSSSSSSSSSSSSSS               \n");usleep(100000);
    Textecolor(7);printf("         zzzzzzzzzzzxt  xzzzzzzzzzy   zzzzzzzzzzzwu  zzzzzzzzzzzz ");Textecolor(9);printf("SSSSSSSSSSSSSSTT               \n");usleep(100000);
    Textecolor(7);printf("         zzzzzzzzzzzxt  xzzzzzzzzzz   xzzzzzzzzzzwu  zzzzzzzzzzzz   ");Textecolor(9);printf("UXWVUUUTUUTSSSSUX             \n");usleep(100000);
    Textecolor(7);printf("         zzzzzzzzzzzxt  xzzzzzzzzzy   wzzzzzzzzzzwu  zzzzzzzzzzzz     ");Textecolor(9);printf("VTSSSSSSSSTTTTWXV           \n");usleep(100000);
    Textecolor(7);printf("         zzzzzzzzzzzxt  xzzzzzzzzzy   wzzzzzzzzzzwu  zzzzzzzzzzzz   zzzzzzzzzzzz                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxt  xzzzzzzzzzy   wzzzzzzzzzzwu  zzzzzzzzzzzz  zzzzzzzzzzzzz                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxt  xzzzzzzzzzy   vzzzzzzzzzzwu  zzzzzzzzzzzz  zzzzzzzzzzzzz                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxt  xzzzzzzzzzy   wzzzzzzzzzzwu  zzzzzzzzzzzz  zyzzzzzzzzzzy                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxu  yzzzzzzzzzy   xzzzzzzzzzzwu                zyzzzzzzzzzzy                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzzyyyzzzzzzzzzzy   xzzzzzzzzzzzyyyyyyyyzyyzzzz  zyzzzzzzzzzzy                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzzzzzzzzzzzzzzzy   zzzzzzzzzzzzzzzzzzzzzzzzzzz  zyzzzzzzzzzzy                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzyyyzzzzzzzzzzzz   nooooooooooooouyzzzzzzzzzzz  xyzzzzzzzzzzy                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxt                              zzzzzzzzzzzzz  xyzzzzzzzzzzy                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxt  yzzzzzzzzzy   xzzzzzzzzzzy  zzzzzzzzzzzzz  xyzzzzzzzzzzy                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxt  yzzzzzzzzzy   wzzzzzzzzzzy  zzzzzzzzzzzzz  zyzzzzzzzzzzy                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxt  yzzzzzzzzzy   wzzzzzzzzzzx  zzzzzzzzzzzzz  zyzzzzzzzzzzz                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxt  yzzzzzzzzzz   xzzzzzzzzzzx  zzzzzzzzzzzzz  zyzzzzzzzzzzy                  \n");usleep(100000);
                  printf("         zzzzzzzzzzzxt  yzzzzzzzzzy   zzzzzzzzzzzw  zzzzzzzzzzzzy  zyzzzzzzzzzzz                  \n");usleep(100000);
                  printf("         oyzzzzzzzzzzzyzzzzzzzzzzzx   wwzzzzzzzzzzyyyzzzzzzzzzzx   xzzzzzzzzzzzz                  \n");usleep(100000);
                  printf("           vyzzzzzzzzzzzzzzzzzzywu      wxzzzzzzzzzzzzzzzzzzzyv    zzzzzzzzzzzzz                  \n");usleep(100000);
                  printf("               nwzzzzzzzzzzzw                zzzzzzzzzzzzz          zzzzzzzzzzzz                  \n");usleep(100000);
    printf("\n\n\n\n");
                    Textecolor(5);

printf("   ________________________________________________________________________\n"
        "  |                                                                        |\n"
        "  |                         Press any key to continue...                   |\n"
        "  |________________________________________________________________________|\n"  );
        getch();
        system("cls");

        Textecolor(14);

    printf(
        "********************************************************************************\n"
        "*                                                                              *\n"
        "*                       ESI ALGIERS LIBRARY MANIPULATION                       *\n"
        "*                                                                              *\n"
        "*                       FSDS TP supervised by DR A.Kermi                       *\n"
        "*                                                                              *\n"
        "*                                 Done by  :                                   *\n"
        "*                              -Ziainia Yacine                                 *\n"
        "*                           -Djouadj Abderrahmane                              *\n"
        "*                                                                              *\n"
        "*                                Group: 5                                      *\n"
        "*                                                                              *\n"
        "*                                2024/2025                                     *\n"
        "*                                                                              *\n"
        "********************************************************************************\n");
        printf("\n");
                Textecolor(5);

printf("   ________________________________________________________________________\n"
        "  |                                                                        |\n"
        "  |                         Press any key to continue...                   |\n"
        "  |________________________________________________________________________|\n"  );

        getch();

/********** WELCOMING PAGE END **********/

        system("cls");
    Textecolor(10);

/********** DESCRIPTION ABOUT ESI ALGIERS LIBRARY **********/
printf("\n");
printf("\n");
printf("\n");

    printf("         __   ___  __   __   __     __  ___    __                __   __       ___     ___  __               __   __        __      \n");
    printf("        |  \\ |__  /__` /  ` |__) | |__)  |  | /  \\ |\\ |     /\\  |__) /  \\ |  |  |     |__  /__` |    |    | |__) |__)  /\\  |__) \\ / \n");
    printf("        |__/ |___ .__/ \\__, |  \\ | |     |  | \\__/ | \\|    /~~\\ |__) \\__/ \\__/  |     |___ .__/ |    |___ | |__) |  \\ /~~\\ |  \\  |   \n");



    Textecolor(9);
    printf("\n\nThe Library of the ESI (Higher School of Computer Science) was established when the school was founded in 1969.\n");
    printf("It offers users a wide range of services, primarily focused on documentation.\n");
    printf("It is an institution mainly specialized in the field of Computer Science.\n");

    Textecolor(11);
    printf("\nLIBRARY STAFF:\n");
    Textecolor(15);  // White
    printf("The library staff consists of:\n");
    Textecolor(15);  // White
    printf("1. A Director\n");
    printf("2. A Head of Processing Services\n");
    printf("3. An Archives Curator\n");
    printf("4. A Level 2 University Library Assistant\n");
    printf("5. Three Library Agents\n");

    Textecolor(14);
    printf("\nThe library is arranged over three levels:\n\n");

        Textecolor(13);

    printf("1 - Basement:\n");
    Textecolor(15);  // White
    printf("It houses the Library's museum, which includes resources (documents, materials, software) related to the history of computer science.\n");
    printf("A section of the library's collection (older versions and editions) is also stored here.\n\n");

        Textecolor(13);

    printf("2 - Ground Floor:\n");
    Textecolor(15);  // White
    printf("A large reading room for students, accommodating 160 students.\n");
    printf("Two microcomputers for research purposes.\n");
    printf("A television for display purposes.\n");
    printf("A grievance register.\n\n");

        Textecolor(13);

    printf("3 - First Floor:\n");
    Textecolor(15);
    printf("A reading room for faculty members.\n");
    printf("Administrative offices.\n");
    printf("A counter dedicated to the borrowing and return of books.\n\n");

    Textecolor(11);
    printf("New Book Acquisitions:\n");
    Textecolor(15);
    printf("Each year, the library purchases new books based on the needs of its users, particularly the needs of the faculty.\n");
    printf("On average, 40 to 60 titles are acquired, with each title consisting of 3 to 5 copies.\n\n");

    Textecolor(12);
    printf("LIBRARY DIRECTOR:\n");
    Textecolor(15);
    printf("Mr. Abderrahmane BELLAHRECHE\n");
    printf("+213 23 93 91 32 Ext. 3059\n");
    printf("a_bellahreche@esi.dz\n\n");

    Textecolor(10);
    printf("Opening Hours:\n");
    Textecolor(15);
    printf("Saturday: 8:30 AM to 4:00 PM\n");
    printf("Sunday to Thursday: 8:30 AM to 10:00 PM\n\n");

    Textecolor(14);  //
    printf("Press any key to manipulate the library ...\n");

    getch();
/********** DESCRIPTION ABOUT ESI ALGIERS LIBRARY END **********/

    system("cls");

/********** Beginning of process (Library Manipulation) **********/

    /* printf("******** LIBRARY MANIPULATION ********\n"); */
    char filename[] = "DOCUMENTS_LIBRARY.BIN";
    char indexFilename[] = "DocumentID_INDEX.BIN";
    int N;
    char choice;



    do {
        Textecolor(10);
/********** Asking the user if he works on new or old(Already created) file **********/

   printf("\n\n");
    printf("     Would you like to create a new file, or work on an old one?\n");
    Textecolor(7);

    printf("\n   --> Enter 'N' for new, 'O' for old: ");
    scanf(" %c", &choice);

        if (choice != 'N' && choice != 'n' && choice != 'O' && choice != 'o') {
                    Textecolor(12);
printf("Invalid choice.\n");
        }
    } while (choice != 'N' && choice != 'n' && choice != 'O' && choice != 'o');

    if (choice == 'N' || choice == 'n') {
        do {
                                    Textecolor(10);
/********** Receiving the number of documents in library from the user **********/

            printf("\n     Enter the number of records : ");
            scanf("%d", &N);

            if (N <= 0) {
                                        Textecolor(12);

                printf("Invalid choice.\n");
            }
        } while (N <= 0);
                    Textecolor(7);

        printf("Loading \n");
        for (int i = 0; i < 3; i++) {
            printf(".");
            fflush(stdout);
            for (volatile long j = 0; j < 1000000000; j++);
        }
                system("cls");

/********** Create LNOF file with randomly generated documents + Creating the INDEX **********/

        initializeLibrary(filename, N);
        qsort(indextab.tab, indextab.taille, sizeof(caseindex), compareCaseIndex); /********** Sorting the index array **********/
    sauvIndexPr("DocumentID_INDEX.BIN", &indextab);

        Textecolor(7);

        printf("\nFile created successfully with %d records!\n", N);
    } else /*** Case n 02 : Manipulating an old (Already created) file ***/ {
            system("cls");

        printf("Loading \n");
        for (int i = 0; i < 3; i++) {
            printf(".");
            fflush(stdout);
            for (volatile long j = 0; j < 1000000000; j++);
        }
        open(&library, filename, 'A');

        printf("\nYou' re using existing file\n");

/********** Loading the index file (Secondary Memory) and copy it into index array (Main Memory) **********/
        loadIndexFromBinaryFile(indexFilename, &indextab);
        printf("Index table loaded from %s.\n", indexFilename);
    }
        Textecolor(10);

 /*   printf("\nDisplaying file content:\n");
                        Textecolor(7); */

   /*  displayLibrary(filename);
                    Textecolor(10);

    printf("\nDisplaying Index Table Content:\n");
                        Textecolor(7);

    printf("---------------------------------------------------------\n");
    printf("| %-5s | %-10s | %-8s | %-10s |\n", "Index", "ID", "Bloc", "Offset");
    printf("---------------------------------------------------------\n");

    for (int i = 0; i < indextab.taille; i++) {
        printf("| %-5d | %-10d | %-8d | %-10d |\n",
               i + 1,
               indextab.tab[i].id,
               indextab.tab[i].bloc,
               indextab.tab[i].dep + 1);
    } */
                    Textecolor(10);


    int menu;

/********** Displaying the Main Menu **********/

    while (menu!=15){
    Textecolor(7);
        Textecolor(9);

    printf("\n          ------ MAIN MENU ------\n");

                        Textecolor(7);

        printf("  [1]   Search by Document ID\n"); /** LNOF **/
        printf("  [2]   Insert a New Document\n"); /** LNOF **/
        printf("  [3]   Delete a Document by ID\n"); /** LNOF **/
        printf("  [4]   Modify the Quantity of a Document\n"); /** LNOF **/
        printf("  [5]   Delete All Documents of a Specific Type\n"); /** LNOF **/
        printf("  [6]   Display Documents of a given type Created in the Last 5 Years\n"); /** LNOF **/
        printf("  [7]   Display All Documents in a Specific Domain\n"); /** LNOF **/
        printf("  [8]   Create TOF File containing documents of type 'Revues et P riodiques'\n"); /** TOF **/
        printf("  [9]   Search by ID in the TOF File\n"); /** TOF **/
        printf("  [10]  Create an Index Table and Index File from the TOF File\n"); /** TOF **/
        printf("  [11]  Search Documents Using the TOF Index\n"); /** TOF **/
                Textecolor(6);
        printf("   - Facultative Modules :\n"); /** Optionnal Modules **/
        printf("  [12]  Display a given file's Header\n");
        printf("  [13]  Display a specific block of a given file\n");
        printf("  [14]  Display full content of a given file\n");
                    Textecolor(7);
          printf("  [15]  Exit the Program\n");
            Textecolor(8);
        printf("\n - Please choose an option : ");
            Textecolor(7);

        scanf("%d", &menu);

    int domainNumber;
    tofentete exampleHeader;
    switch (menu){

case 14: /********** Display full content of a given file **********/


    printf("");
    int content=0;
    while (content<1 || content>2){
        printf("---> Choose a file to display its content :\n 1. LnOF file\n 2. TOF file\n---> ");
        scanf("%d", &content);
    }
    if (content==1){
                Textecolor(11);
        printf("\nDisplaying LnOF file content :\n");
                            Textecolor(7);

        displayLibrary(filename);
                        Textecolor(10);

        printf("\nDisplaying Index Table Content:\n");
                            Textecolor(7);

        printf("---------------------------------------------------------\n");
        printf("| %-5s | %-10s | %-8s | %-10s |\n", "Index", "ID", "Bloc", "Offset");
        printf("---------------------------------------------------------\n");

        for (int i = 0; i < indextab.taille; i++) {
            printf("| %-5d | %-10d | %-8d | %-10d |\n",
                   i + 1,
                   indextab.tab[i].id,
                   indextab.tab[i].bloc,
                   indextab.tab[i].dep + 1);
        }
    } else {
        if(TOF_created){displayTOF("JOURNAL_MAGAZINE.BIN");}
        else{Textecolor(12);printf("Step 8 should be treated first!\n");Textecolor(7);}
    }
                    Textecolor(7);
    break;
 case 13: /********** Display a specific block of a given file **********/
     printf("");
    int block=0;
    while (block<1 || block>2){
        printf("---> Choose a file to display a block :\n 1. LnOF file\n 2. TOF file\n---> ");
        scanf("%d", &block);
    }
    if (block==1){
        do {
            printf("Enter the block number to display (greater than 0): ");
            scanf("%d", &blockNumber);
            if (blockNumber > 0) {
                displayBlock("DOCUMENTS_LIBRARY.BIN", blockNumber+1);
            } else {
                printf("Please enter a number greater than 0.\n");
            }
        } while (blockNumber <= 0);
    } else {
        if(TOF_created){
            do {
            printf("Enter the block number to display (greater than 0): ");
            scanf("%d", &blockNumber);
            if (blockNumber > 0) {
                displayblock_tof("JOURNAL_MAGAZINE.BIN", blockNumber);
            } else {
                printf("Please enter a number greater than 0.\n");
            }
            } while (blockNumber <= 0);

        }
        else{Textecolor(12);printf("Step 8 should be treated first!\n");Textecolor(7);}
    }
    break;
    case 5:  /*********** Delete All Documents of a Specific Type ***********/
        Textecolor(11);
            printf("\n ----- Deleting by TYPE -----\n");
            Textecolor(10);
        printf("Enter the document type number to remove from the file:\n");
                            Textecolor(7);

        printf("1. Ouvrages et manuels\n");
        printf("2. Revues et periodiques\n");
        printf("3. Actes de conferences\n");
        printf("4. Rapports de recherche\n");
        printf("5. Memoires et theses\n");
        printf("6. Polycopies et support de cours\n");
        int typeToRemove=0;
                            Textecolor(10);
        while (typeToRemove <1 || typeToRemove >6){
            printf("Enter your choice (1-6): ");
            scanf("%d", &typeToRemove);
        }
            Textecolor(12);
        removeRecordsByType(typeToRemove);

    sauvIndexPr(indexFilename, &indextab);
                        Textecolor(7);

    printIndexFile(indexFilename);
                    Textecolor(10);
        break;
case 1: /********** Search by Document ID **********/
    Textecolor(11);
    printf("\n----- Searching Operation -----\n");
    Textecolor(12);
    printf("Please enter the ID: \n");
    scanf("%d", &idToSearch);
                    Textecolor(7);

    SearchResult result;
    result = binarysearch(idToSearch);
    if (result.dep != -1) {
        printf("Record found!\n");
        printf("Number of bloc: %d\n", result.bloc);
        printf("Dep (Offset): %d\n", result.dep);
    } else {
        printf("Record with ID %d not found.\n", idToSearch);
    }
   printf("\n+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C33): %d |\n", 0);
    printf("+-----------------------------------------------+\n");
    break;
    case 7: /**********Display All Documents in a Specific Domain **********/
                                Textecolor(11);

        printf("Enter the domain number (1 to 12) to display records of this domain\n");
        for (int i = 0; i < 12; i++) {
                                    Textecolor(7);

            printf("%d. %s\n", i + 1, domains[i]);
        }
        Textecolor(10);
        int domainNumber=0;
        while (domainNumber <1 || domainNumber>12){
        printf("Enter your choice (1->12): ");
        scanf("%d", &domainNumber);}

    displaydomain(domainNumber);

        break;
    case 6: /********** Display Documents of a given type Created in the Last 5 Years **********/
        Textecolor(10);

        printf("Enter the document type number to display documents of this type from the last 5 years:\n");
                            Textecolor(7);

        printf("1. Ouvrages et manuels\n");
        printf("2. Revues et periodiques\n");
        printf("3. Actes de conferences\n");
        printf("4. Rapports de recherche\n");
        printf("5. Memoires et theses\n");
        printf("6. Polycopies et support de cours\n");
                                    Textecolor(11);
        int year;
    year = getyear(); /* get actual year using library time.h */
    int typeToDisplay=0;
        while (typeToDisplay <1 || typeToDisplay>6){
        printf("Enter your choice (1-6): ");
        scanf("%d", &typeToDisplay);}
        Textecolor(7);

    displaytypeyear(typeToDisplay, year);
        break;
    case 8: /********** Create TOF File containing documents of type 'Revues et P riodiques **********/
        printf("");
    const char *inputFile = "DOCUMENTS_LIBRARY.BIN";
    const char *outputFile = "JOURNAL_MAGAZINE.BIN";

    createTOF(inputFile, outputFile);
    TOF_created =1;
                                            Textecolor(7);

    displayTOF("JOURNAL_MAGAZINE.BIN");
break;
    case 9: /********** Search by ID in the TOF File **********/
    if (TOF_created){
            Textecolor(11);
        printf("\nSearching by ID in TOF file\n");
                                                Textecolor(12);
        int searchId;

        printf("\nEnter the ID : ");
        scanf("%d",&searchId);
        Textecolor(7);

        searchByIdInTOF("JOURNAL_MAGAZINE.BIN", searchId);

        close(&library);
        Textecolor(7);
    } else {Textecolor(12);printf("Step 8 should be treated first!\n");Textecolor(7);}

    break;
    case 2: /*********** Insert a New Document **********/
        Textecolor(11);
        printf("\n---Inserting a new document---\n");
        Textecolor(7);
        insert_document();
        break;

    case 3: /*********** Deletnig a Document **********/
        Textecolor(11);
        printf("\n---Deleting a document---\n");
        Textecolor(12);
        int idToDelete;
        printf("Enter the ID of the document you wish to delete : ");
        Textecolor(7);
        scanf("%d", &idToDelete);
        delete_document(idToDelete);
        break;

    case 4: /********** Modifying the quantity of a document **********/
        Textecolor(11);
        printf("\n---Modifying the quantity of a document---\n");
        Textecolor(12);
        int idToModify;
        printf("Enter the ID of the document you wish to modify its quantity : ");
        Textecolor(7);
        scanf("%d", &idToModify);
        SearchResult res;
        res = binarysearch(idToModify);
        if (res.dep != -1){
            int q=0;
            while (q<1 || q>10){
                    Textecolor(12);
                printf("Enter the new quantity for the document : ");
            Textecolor(7);
                scanf("%d", &q);
            }
            modify_quantity(idToModify, q, res);
        } else {
            Textecolor(12);
            printf("Record with ID %d not found.\n", idToModify); Textecolor(7);
        }
        break;

    case 10: /*********** Create an Index Table and Index File from the TOF File **********/
        if (TOF_created){
                Textecolor(7);
                create_indextabTOF("JOURNAL_MAGAZINE.BIN");
                indextabtof_created =1;
                display_indextabTOF();
                sauvIndexPr("INDEXFILE_TOF.BIN", &indextab_TOF);
                printIndexFile("INDEXFILE_TOF.BIN");
        }
        else {Textecolor(12);printf("Step 8 should be treated first!\n");Textecolor(7);}
        break;
    case 11: /*********** Search Documents using TOF index ***********/
        if (TOF_created && indextabtof_created){
                Textecolor(11);
            printf("---SEARCHING USING INDEX TOF---\n");
        Textecolor(12);
            int id;
            printf("Enter id : ");
            Textecolor(7);
            scanf("%d", &id);
            binarysearch_indextabTOF(id);
        }
        else {Textecolor(12);printf("Step 8 and 10 should be treated first!\n");Textecolor(7);}
        break;
    case 15: /*********** Quit the program **********/
        Textecolor(12);
        printf("Exiting..."); Textecolor(7);
        break;

    case 12: /*********** Displaying header of given file ***********/
        printf("");
        int header=0;
        while (header<1 || header>2){
            printf("---> Choose a file to display its header :\n 1. LnOF file\n 2. TOF file\n---> ");
            scanf("%d", &header);
        }
        if(header==1){ displayTentete("DOCUMENTS_LIBRARY.BIN") ;}
        else{
                if (TOF_created){displaytofentete("JOURNAL_MAGAZINE.BIN");}
                else{Textecolor(12);printf("Step 8 should be treated first!\n");Textecolor(7);}
        }

    break;
    default:
        Textecolor(13);
        printf("*%d is not a valid option! Try Again.", menu); Textecolor(7);
        break;
    }
    }

    return 0;
}

/*********** Return the head or tail of LNOF File ***********/
int getheader(LnOF *fichier, int i) {
    if (i == 1) {
        return fichier->entete.tete;
    } else if (i == 2) {
        return fichier->entete.queue;
    } else {
        return -1;
    }
}
/*********** Modifying the head or tail of LNOF File ***********/

void setheader(LnOF *fichier, int i, int val) {
    if (i == 1) {
        fichier->entete.tete = val;
    } else if (i == 2) {
        fichier->entete.queue = val;
    }
}
/*********** Opening file, 2 MODES : A (Ancient) & N (New) ***********/

void open(LnOF *fichier, char *nomF, char mode) {
    if ((mode == 'N') || (mode == 'n')) {
        fichier->f = fopen(nomF, "wb+");
        if (fichier->f != NULL) {
            setheader(fichier, 1, 1);
            setheader(fichier, 2, 1);
        }
    } else if ((mode == 'A') || (mode == 'a')) {
        fichier->f = fopen(nomF, "rb+");
        if (fichier->f != NULL) {
            fread(&(fichier->entete), sizeof(Tentete), 1, fichier->f);
        }
    } else {
        fichier->f = NULL;
    }
}
/*********** Closing File ***********/

void close(LnOF *fichier) {
    if (fichier != NULL && fichier->f != NULL) {
        rewind(fichier->f);
        fwrite(&(fichier->entete), sizeof(Tentete), 1, fichier->f);
        fclose(fichier->f);
        fichier->f = NULL;
    }
}
/*********** Read a bloc of a file  ***********/

void readbloc(LnOF *fichier, int i, Tbloc *buf) {
    if (fichier->f != NULL) {
        fseek(fichier->f, (i - 1) * sizeof(Tbloc) + sizeof(Tentete), SEEK_SET);
        fread(buf, sizeof(Tbloc), 1, fichier->f);
        nombreLireDir++;
    }
}

/*********** Writing a bloc of a file  ***********/

void writebloc(LnOF *fichier, int i, Tbloc *buf) {
    if (fichier->f != NULL) {
        fseek(fichier->f, (i - 1) * sizeof(Tbloc) + sizeof(Tentete), SEEK_SET);
        fwrite(buf, sizeof(Tbloc), 1, fichier->f);
        nombreEcrireDir++;
    }
}

/*********** Creating a new bloc ***********/

int allocbloc(LnOF *fichier) {
    Tbloc buf;
    if (fichier->f != NULL) {
        readbloc(fichier, getheader(fichier, 2), &buf);
        buf.suivant = getheader(fichier, 2) + 1;
        writebloc(fichier, getheader(fichier, 2), &buf);
        buf.NB = 0;
        buf.suivant = -1;

        setheader(fichier, 2, getheader(fichier, 2) + 1);
        writebloc(fichier, getheader(fichier, 2), &buf);

        return getheader(fichier, 2);
    } else {
        return -1;
    }
}

/*********** Generating random: ID, TITLE&TITLE's LENGTH, AUTHOR&AUTHOR's LENGTH, TYPE(1-6), DOMAIN(1-2), PUBLICATION YEAR(1970-2024), QUANTITY  ***********/

void generateRandomRecord(Tenreg *record) {
    int repeat = 1;
    while (repeat == 1) {
        //record->id = rand() % (990000 - 110000 + 1) + 110000;
        record->id = (rand()*rand()) % (990000 - 110000 + 1) + 110000;

        repeat = 0;
        for (int i = 0; i < indextab.taille; i++) {
            if (indextab.tab[i].id == record->id) {
                repeat = 1;
                break;
            }
        }
    }


    int titleLen = rand() % (70 - 50 + 1) + 50;
    for (int i = 0; i < titleLen; i++) {
        record->title[i] = 'A' + (rand() % 26);
    }
    record->title[titleLen] = '\0';

    int authorLen = rand() % (30 - 4 + 1) + 4;
    for (int i = 0; i < authorLen; i++) {
        record->author[i] = 'A' + (rand() % 26);
    }
    record->author[authorLen] = '\0';

    record->type = rand() % 6 + 1;
    record->domain = rand() % 12 + 1;
    record->pub_year = rand() % (2024 - 1970 + 1) + 1970;
    record->qty = rand() % 10 + 1;
}

/*********** Filling a number of records given by random generated informations  ***********/

void initializeLibrary(char *filename, int N) {
       int C2 = 0;

    open(&library, filename, 'N');

    Tbloc bloc = {.NB = 0, .suivant = -1};
    indextab.taille = 0;

    for (int i = 0; i < N; i++) {
        if (bloc.NB == MAX_RECORDS) {
            writebloc(&library, library.entete.queue, &bloc); C2++;
            allocbloc(&library); C2=C2+3 ;
            bloc.NB = 0;
        }

        Tenreg newRecord;
        generateRandomRecord(&newRecord);

        bloc.tab[bloc.NB] = newRecord;

        indextab.tab[indextab.taille].id = newRecord.id;
        indextab.tab[indextab.taille].bloc = library.entete.queue;
        indextab.tab[indextab.taille].dep = bloc.NB;

        bloc.NB++;
        indextab.taille++;
    }

    if (bloc.NB > 0) {
        writebloc(&library, library.entete.queue, &bloc); C2++;
    }

    close(&library); C2++;
 printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C2): %d |\n", C2);
    printf("+-----------------------------------------------+\n");
}

/*********** Displaying the LNOF File bloc per bloc  ***********/

void displayLibrary(char *filename) {
    int C73a = 0;
    LnOF library;
    open(&library, filename, 'A'); C73a++;

    Tbloc bloc;
    int currentBlock = library.entete.tete;
    int blockCounter = 1;

    printf("\n*** File Content '%s' ***\n", filename);
    int j;

    while (currentBlock != -1) { /*********** END Condition  ***********/

        readbloc(&library, currentBlock, &bloc); C73a++;
        printf("Bloc %d :\n", blockCounter);
        j=0;

        for (int i = 0; i < bloc.NB; i++) {
            Tenreg record = bloc.tab[i];
             if (record.qty == 0) {
                continue;
            }
                                        Textecolor(9);
            j++;
            printf("  The Record %d:\n", j);
                                                    Textecolor(7);

            printf("    ID          : %d\n", record.id);
            printf("    Title       : %s\n", record.title);
            printf("    Author      : %s\n", record.author);
            printf("    Type        : %s\n", types[record.type - 1]);
            printf("    Domain      : %s\n", domains[record.domain - 1]);
            printf("    Pub Year    : %d\n", record.pub_year);
            printf("    Quantity    : %d\n", record.qty);
        }

        currentBlock = bloc.suivant; /*********** Accessing the next bloc  ***********/

        blockCounter++;
        printf("\n");
    }

    close(&library); C73a++;
    printf("*** File END ***\n");
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C73a): %d |\n", C73a);
    printf("+-----------------------------------------------+\n");
}
/*********** Important function to qsort  ***********/

int compareCaseIndex(const void *a, const void *b) {
    const caseindex *caseA = (const caseindex *)a;
    const caseindex *caseB = (const caseindex *)b;

    return caseA->id - caseB->id;
}

/*********** Saving index array (Main Memory) in index file (Secondary Memory)  ***********/

void sauvIndexPr(char nomIndex[], index *indexp)
{
    int C31=0;
    fIndex ifichier;
    tBlocIndex buf;
    int j = 0, i = 1;

    ifichier.f = fopen(nomIndex, "wb");

    if (ifichier.f != NULL)
    {
        fseek(ifichier.f, sizeof(iEntete), SEEK_SET);

        for (int k = 0; k < indexp->taille; k++)
        {
            if (j < MAX_BLOC_INDEX)
            {
                buf.tab[j] = indexp->tab[k];
                j++;
            }
            else
            {
                buf.NB = j;
                fwrite(&buf, sizeof(tBlocIndex), 1, ifichier.f); C31++;
                i++;

                buf.tab[0] = indexp->tab[k];
                j = 1;
            }
        }

        if (j > 0)
        {
            buf.NB = j;
            fwrite(&buf, sizeof(tBlocIndex), 1, ifichier.f); C31++;
        }

        ifichier.entete.nbBloc = i;

        rewind(ifichier.f);
        fwrite(&(ifichier.entete), sizeof(iEntete), 1, ifichier.f); C31++;

        fclose(ifichier.f);
    }
}

/*********** Printing the INDEX File  ***********/

void printIndexFile(const char *filename) {
    fIndex indexFile;
    tBlocIndex block;

    indexFile.f = fopen(filename, "rb");
    if (indexFile.f == NULL) {
        printf("Error \n", filename);
        return;
    }

    fread(&(indexFile.entete), sizeof(iEntete), 1, indexFile.f);
    printf("\n** Number of blocks in the index file: %d **\n", indexFile.entete.nbBloc);
    printf("--- Content of index file : ---\n");


    for (int i = 0; i < indexFile.entete.nbBloc; i++) {
    fseek(indexFile.f, sizeof(iEntete) + i * sizeof(tBlocIndex), SEEK_SET);
        fread(&block, sizeof(tBlocIndex), 1, indexFile.f);

        printf("\nBlock %d:\n", i + 1);
        printf("---------------------------------------------------------\n");
        printf("| %-5s | %-10s | %-8s | %-10s |\n", "Index", "ID", "Bloc", "Offset");
        printf("---------------------------------------------------------\n");

        for (int j = 0; j < block.NB; j++) {
            printf("| %-5d | %-10d | %-8d | %-10d |\n",
                   j + 1,
                   block.tab[j].id,
                   block.tab[j].bloc,
                   block.tab[j].dep+1);
        }
        printf("---------------------------------------------------------\n");
    }

    fclose(indexFile.f);
}

/*********** Binary Search in INDEX Array, it returns BLOC NUMBER & OFFSET IN BLOC  ***********/

SearchResult binarysearch(int searchId) {

    int low = 0;
    int high = indextab.taille - 1;
    SearchResult result = {-1,0};

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (indextab.tab[mid].id == searchId) {
            result.dep = indextab.tab[mid].dep+1;
            result.bloc = indextab.tab[mid].bloc;
            return result;
        } else if (indextab.tab[mid].id < searchId) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    return result;
}

/*********** Index FILE (Secondary Memory) ---(Loading)---> Index ARRAY (Main Memory)  ***********/

void loadIndexFromBinaryFile(const char *filename, index *indextab) {
    fIndex indexFile;
    tBlocIndex block;
int C32 = 0;
    indexFile.f = fopen(filename, "rb");
    if (indexFile.f == NULL) {
        printf("Error\n");
        return;
    }

    fread(&(indexFile.entete), sizeof(iEntete), 1, indexFile.f); C32++;
    indextab->taille = 0;

    for (int i = 0; i < indexFile.entete.nbBloc; i++) {
        fread(&block, sizeof(tBlocIndex), 1, indexFile.f); C32++;

        for (int j = 0; j < block.NB; j++) {
            indextab->tab[indextab->taille] = block.tab[j];
            indextab->taille++;
        }
    }

    fclose(indexFile.f);
    printf("Index loaded successfully from '%s'.\n", filename);
             printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C32): %d |\n", C32);
    printf("+-----------------------------------------------+\n");
}

/*********** Deleting a record in LNOF, the user gives the document's ID & Updating the Index Array  ***********/

void delete_document(int idToDelete) {
    SearchResult result;
    int C35 = 0;

    result = binarysearch(idToDelete);
    if (result.dep != -1) {
        LnOF library;
        open(&library, "DOCUMENTS_LIBRARY.BIN", 'A'); C35++;

        Tbloc bloc;
        int currentBlock = library.entete.tete;
        int blockCounter = 1;
        while (currentBlock != -1) {
            readbloc(&library, currentBlock, &bloc);
            C35++;
            if (blockCounter == result.bloc) {
                break;
            }
            currentBlock = bloc.suivant;
            blockCounter++;
        }

        bloc.tab[result.dep - 1].qty = 0;
        int low = 0;
        int high = indextab.taille - 1;
        int deleteIndex = -1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (indextab.tab[mid].id == idToDelete) {
                deleteIndex = mid;
                break;
            }
            if (indextab.tab[mid].id < idToDelete) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        if (deleteIndex != -1) {
            for (int k = deleteIndex; k < indextab.taille - 1; k++) {
                indextab.tab[k] = indextab.tab[k + 1];
            }
            indextab.taille--;
        } else {
            printf("Document not found in the index tab \n");
            return;
        }

        writebloc(&library, currentBlock, &bloc);
        C35++;
        sauvIndexPr("DocumentID_INDEX.BIN", &indextab);
        close(&library);
        printf("Document deleted successfully!\n");
    } else {
        printf("Record with ID %d not found.\n", idToDelete);
    }

    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C35): %10d |\n", C35);
    printf("+-----------------------------------------------+\n");
}

/*********** Modify the quantity of a given document ( Increasing or Decreasing )  ***********/

void modify_quantity(int idToDelete, int q, SearchResult result){
    int C36 = 0;
        LnOF library;
        open(&library, "DOCUMENTS_LIBRARY.BIN", 'A'); C36++;

        Tbloc bloc;
        int currentBlock = library.entete.tete;
        int blockCounter = 1;

        while (currentBlock!=-1) {
            readbloc(&library, currentBlock, &bloc); C36++;
            if (blockCounter == result.bloc){break;}
            currentBlock = bloc.suivant;
            blockCounter++;
        }

        bloc.tab[result.dep-1].qty=q;

        writebloc(&library, currentBlock, &bloc); C36++;
        sauvIndexPr("DocumentID_INDEX.BIN", &indextab);
        close(&library);
C36++;
        printf("Quantity modified successfully!\n");
        printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C36): %10d |\n", C36);
    printf("+-----------------------------------------------+\n");
}

/*********** Inserting a given document into LNOF File ( Informations are given by the user - Not Randomly Generated - excepting the ID Key )  ***********/

void insert_document(){
    int C34 = 0;
    LnOF library;
    open(&library, "DOCUMENTS_LIBRARY.BIN", 'A'); C34++;

    Tbloc bloc;
    readbloc(&library, library.entete.queue, &bloc); C34++ ;


    if (bloc.NB == MAX_RECORDS) {
            writebloc(&library, library.entete.queue, &bloc); C34++;
            allocbloc(&library); C34 = C34+3 ;
            bloc.NB = 0;
        }
     Tenreg newRecord;

    int repeat = 1;
        while (repeat == 1) {
            newRecord.id = rand() % (990000 - 110000 + 1) + 110000;

            repeat = 0;
            for (int i = 0; i < indextab.taille; i++) {
                if (indextab.tab[i].id == newRecord.id) {
                    repeat = 1;
                    break;
                }
            }
        }

    int ch;
    while ((ch = getchar()) != '\n' && ch != EOF);

    int i;
    char ch1[71];
    printf("Enter the title of the document: ");
    for (i=0; i<71; i++){
        scanf("%c", &ch1[i]);
        if (ch1[i]=='\n'){
            break;
        }
    }
    strncpy(newRecord.title, ch1, sizeof(newRecord.title) - 1);
    newRecord.title[i] = '\0';

    if (i>70){while ((ch = getchar()) != '\n' && ch != EOF);}

    char ch2[31];
    printf("Enter the name of the author: ");
    for (i=0; i<31; i++){
        scanf("%c", &ch2[i]);
        if (ch2[i]=='\n'){
            break;
        }
    }
    strncpy(newRecord.author, ch2, sizeof(newRecord.author) - 1);
    newRecord.author[i] = '\0';

    if (i>30){while ((ch = getchar()) != '\n' && ch != EOF);}


    int type=0;
    while (type <1 || type >6){
    printf("Enter the type of the document (1-6): ");
    scanf("%d", &type);}
    newRecord.type = type;

    int domain=0;
    while (domain <1 || domain >12){
    printf("Enter the domain of the document (1-12): ");
    scanf("%d", &domain);}
    newRecord.domain = domain;

    int pubyear=0;
    while (pubyear <1970 || pubyear >getyear()){
    printf("Enter the year of publication : ");
    scanf("%d", &pubyear);}
    newRecord.pub_year = pubyear;

    int q=0;
    while (q <1 || q >10){
    printf("Enter the quantity : ");
    scanf("%d", &q);}
    newRecord.qty = q;

     bloc.tab[bloc.NB] = newRecord;


    indextab.tab[indextab.taille].id = newRecord.id;
    indextab.tab[indextab.taille].bloc = library.entete.queue;
    indextab.tab[indextab.taille].dep = bloc.NB;

    bloc.NB++;
         writebloc(&library, library.entete.queue, &bloc); C34++ ;


    indextab.taille++;

    qsort(indextab.tab, indextab.taille, sizeof(caseindex), compareCaseIndex); // Sort the index


    sauvIndexPr("DocumentID_INDEX.BIN", &indextab);
    close(&library); C34++; printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C34): %10d |\n", C34);
    printf("+-----------------------------------------------+\n");

}

/*********** Removing all documents of a given type in LNOF File && Updating the Index Array ***********/

void removeRecordsByType(int typeToRemove) {
    int C41 = 0;
    LnOF library;
    open(&library, "DOCUMENTS_LIBRARY.BIN", 'A'); C41++;

    Tbloc bloc;
    int currentBlock = library.entete.tete;
    int blockCounter = 1;

    while (currentBlock != -1) {
        readbloc(&library, currentBlock, &bloc); C41++;

        for (int i = 0; i < bloc.NB; i++) {
            if (bloc.tab[i].type == typeToRemove) {
                bloc.tab[i].qty = 0; /* logical deletion */

            for (int j = 0; j < indextab.taille; j++) {
                if (indextab.tab[j].id == bloc.tab[i].id) {
                for (int k = j; k < indextab.taille - 1; k++) {
                            indextab.tab[k] = indextab.tab[k + 1];
                        }

                        indextab.taille--;
                        break;
    }}}}

        writebloc(&library, currentBlock, &bloc); C41++;

        currentBlock = bloc.suivant;
        blockCounter++;
    }

    sauvIndexPr("DocumentID_INDEX.BIN", &indextab);
    close(&library);  C41++;


    printf("Records of type '%s' removed. \n", types[typeToRemove -1]);
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C41): %10d |\n", C41);
    printf("+-----------------------------------------------+\n");
}

/*********** Displaying all records of a given domain contained in LNOF ***********/

void displaydomain(int domainn) {
    int C43 = 0;
    LnOF library;
    open(&library, "DOCUMENTS_LIBRARY.BIN", 'A'); C43++;

    Tbloc bloc;
    int currentBlock = library.entete.tete;
    int recordfound = 0;

    while (currentBlock != -1) {
        readbloc(&library, currentBlock, &bloc); C43++;

        for (int i = 0; i < bloc.NB; i++) {
            if (bloc.tab[i].domain == domainn && bloc.tab[i].qty>0) {
                    Textecolor(7);
                printf("ID: %d\n\tDomain: %s\n\tQuantity: %d\n\tType: %s\n\tAuthor: %s\n\tTitle: %s\n\tPub Year: %d\n",
                       bloc.tab[i].id, domains[bloc.tab[i].domain -1], bloc.tab[i].qty,
                       types[bloc.tab[i].type -1], bloc.tab[i].author, bloc.tab[i].title, bloc.tab[i].pub_year);
                recordfound = 1;
            }
        }

        currentBlock = bloc.suivant;
    }

    if (recordfound == 0) {
            Textecolor(12);
        printf("No records found for domain %d.\n", domainn);
    Textecolor(7);
    }

    close(&library); C43++;
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C43): %10d |\n", C43);
    printf("+-----------------------------------------------+\n");
}

/*********** Getting the actual year, using predefined C functions ***********/

int getyear() {
    time_t t = time(NULL);

    struct tm *tm_info = localtime(&t);

    return tm_info->tm_year + 1900;
}

/*********** Display new (Not older than 5 years) documents of a given type  ***********/

void displaytypeyear(int type, int currentYear) {
    int C42 = 0;
    LnOF library;
    open(&library, "DOCUMENTS_LIBRARY.BIN", 'A'); C42++;

    Tbloc bloc;
    int currentBlock = library.entete.tete;
    int blockCounter = 1;

    printf("\n*** Documents of type '%s' (Last 5 years) ***\n", types[type-1]);

    while (currentBlock != -1) {
        readbloc(&library, currentBlock, &bloc); C42++;
        //printf("Bloc %d (Number of records : %d):\n", blockCounter, bloc.NB);

        for (int i = 0; i < bloc.NB; i++) {
            Tenreg record = bloc.tab[i];

            if (record.qty != 0 && record.type == type && (currentYear - record.pub_year) <= 5) {
            //    continue;
            Textecolor(7);

            printf("  The Record %d:\n", i + 1);
            printf("    ID          : %d\n", record.id);
            printf("    Title       : %s\n", record.title);
            printf("    Author      : %s\n", record.author);
            printf("    Type        : %s\n", types[record.type - 1]);
            printf("    Domain      : %s\n", domains[record.domain - 1]);
            printf("    Pub Year    : %d\n", record.pub_year);
            printf("    Quantity    : %d\n", record.qty);}
        }

        currentBlock = bloc.suivant;
        blockCounter++;
        //printf("\n");
    }

    close(&library); Textecolor(12); ; C42++;
    printf("*** End of Documents ***\n"); Textecolor(7);
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C42): %10d |\n", C42);
    printf("+-----------------------------------------------+\n");
}

/*********** Function to modify console's text color, using decimal code numbers  ***********/

void Textecolor(int ForgC)
{
  WORD wColor;

  HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
  CONSOLE_SCREEN_BUFFER_INFO csbi;

  if (GetConsoleScreenBufferInfo(hStdOut, &csbi))
  {
    wColor = (csbi.wAttributes & 0xF0) + (ForgC & 0x0F);
    SetConsoleTextAttribute(hStdOut, wColor);
  }
  return;
}

/*********** Creating TOF File containing the documents of type "Revues et periodiques" from LNOF File  ***********/

void createTOF(const char *inputFile, const char *outputFile) {
    int C5 = 0;
    LnOF library;
    FILE *tofFile;
    Tbloc bloc;
    TblocTOF tofBloc;
    Tenreg *journalMagazines = NULL;
    int numRecords = 0, numBlocks = 0;
    open(&library, inputFile, 'A'); C5++;
    tofFile = fopen(outputFile, "wb");
    if (tofFile == NULL) {
        printf("Error");
        close(&library);
        return;
    }

    tofentete header = {0};
    fwrite(&header, sizeof(tofentete), 1, tofFile); C5++;

    int currentBlock = library.entete.tete;
    while (currentBlock != -1) {
        readbloc(&library, currentBlock, &bloc);
        C5++;
        for (int i = 0; i < bloc.NB; i++) {
            if (bloc.tab[i].type == 2 && bloc.tab[i].qty > 0) {
                journalMagazines = realloc(journalMagazines, (numRecords + 1) * sizeof(Tenreg));
                if (journalMagazines == NULL) {
                    printf("Error: Memory allocation failed.\n");
                    fclose(tofFile);
                    close(&library);
                    return;
                }
                journalMagazines[numRecords++] = bloc.tab[i];
            }
        }
        currentBlock = bloc.suivant;
    }

    qsort(journalMagazines, numRecords, sizeof(Tenreg), compareByID);

    int currentRecord = 0;
    while (currentRecord < numRecords) {
        tofBloc.NB = 0;

        for (int i = 0; i < MAX_RECORDS && currentRecord < numRecords; i++) {
            tofBloc.tab[i] = journalMagazines[currentRecord++];
            tofBloc.NB++;
        }

        fwrite(&tofBloc, sizeof(TblocTOF), 1, tofFile);
        C5++;
        numBlocks++;
    }

    header.nbBloc = numBlocks;
    fseek(tofFile, 0, SEEK_SET);
    fwrite(&header, sizeof(tofentete), 1, tofFile);
    C5++;
    fclose(tofFile);
    fclose(library.f);

    free(journalMagazines);

    printf("TOF file '%s' created with %d records\n", outputFile, numRecords);
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C5): %10d |\n", C5);
    printf("+-----------------------------------------------+\n");
}

int compareByID(const void *a, const void *b) {
    Tenreg *recordA = (Tenreg *)a;
    Tenreg *recordB = (Tenreg *)b;

    return recordA->id - recordB->id;
}

/*********** Creating the Index Array of TOF File (The index doesn't contain all the records, we benefit from the fact that TOF File is ordered ***********/

void create_indextabTOF(const char *filename){
    int C62 = 0 ;
    FILE *tofFile;
    TblocTOF tofBloc;
    tofentete header;
    int j=0;

    tofFile = fopen(filename, "rb");
    if (tofFile == NULL) {
        printf("Error opening file '%s'.\n", filename);
        return;
    }

    fread(&header, sizeof(tofentete), 1, tofFile); C62++;

    for (int i = 0; i < header.nbBloc; i++) {
        fseek(tofFile, sizeof(tofentete) + i * sizeof(TblocTOF), SEEK_SET);
        fread(&tofBloc, sizeof(TblocTOF), 1, tofFile); C62 ++;
        if (tofBloc.NB>0){
            indextab_TOF.tab[j].id = tofBloc.tab[tofBloc.NB-1].id;
            indextab_TOF.tab[j].dep = tofBloc.NB-1;
            indextab_TOF.tab[j].bloc = i+1;
            j++;
        }
    }
    indextab_TOF.taille=j;
    fclose(tofFile);
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C62): %10d |\n", C62);
    printf("+-----------------------------------------------+\n");
}

/*********** Displaying the TOF's INDEX  ***********/

void display_indextabTOF(){
    printf("\nDisplaying Index Table Content:\n");
    printf("---------------------------------------------------------\n");
    printf("| %-5s | %-10s | %-8s | %-10s |\n", "Index", "ID", "Bloc", "Offset");
    printf("---------------------------------------------------------\n");

    for (int i = 0; i < indextab_TOF.taille; i++) {
        printf("| %-5d | %-10d | %-8d | %-10d |\n",
               i + 1,
               indextab_TOF.tab[i].id,
               indextab_TOF.tab[i].bloc,
               indextab_TOF.tab[i].dep + 1);
    }
}

/*********** Binary Search in TOF's INDEX Array && Displaying the record ***********/

void binarysearch_indextabTOF(int id) {
    int low = 0;
    int high = indextab_TOF.taille - 1;
    int dep,blck;
    int found=0;

    while (low <= high) {
        int mid = (high + low) / 2;

        if (indextab_TOF.tab[mid].id == id) {
            dep = indextab_TOF.tab[mid].dep+1;
            blck = indextab_TOF.tab[mid].bloc;
            found =1;
            break;
        } else if (indextab_TOF.tab[mid].id < id) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    if (!found){
        FILE *tofFile;
        TblocTOF tofBloc;
        tofentete header;
        tofFile = fopen("JOURNAL_MAGAZINE.BIN", "rb");
        if (tofFile == NULL) {
            printf("Error opening file '%s'.\n", "JOURNAL_MAGAZINE.BIN");
            return;
        }

        fread(&header, sizeof(tofentete), 1, tofFile);

        fseek(tofFile, sizeof(tofentete) + low * sizeof(TblocTOF), SEEK_SET);
        fread(&tofBloc, sizeof(TblocTOF), 1, tofFile);

        int low1 = 0;
        int high1 = tofBloc.NB;
        int dep1;
        int found1=0;

        while (low1 <= high1) {
            int mid1 = (high1 + low1) / 2;

            if (tofBloc.tab[mid1].id == id) {
                dep1 = mid1;
                //blck1 = tofBloc.tab[mid1].bloc;
                found1 =1;
                break;
                //return result;
            } else if (tofBloc.tab[mid1].id < id) {
                low1 = mid1 + 1;
            } else {
                high1 = mid1 - 1;
            }
        }

        if (found1){
            printf("\nRecord found! ID: %d\n", tofBloc.tab[dep1].id);
            printf("  Title       : %s\n", tofBloc.tab[dep1].title);
            printf("  Author      : %s\n", tofBloc.tab[dep1].author);
            printf("  Type        : %s\n", types[tofBloc.tab[dep1].type-1]);
            printf("  Domain      : %s\n", domains[tofBloc.tab[dep1].domain-1]);
            printf("  Pub Year    : %d\n", tofBloc.tab[dep1].pub_year);
            printf("  Quantity    : %d\n", tofBloc.tab[dep1].qty);
        } else {printf("There is no document with ID '%d'!", id);}

    } else {
        FILE *tofFile;
        TblocTOF tofBloc;
        tofentete header;
        tofFile = fopen("JOURNAL_MAGAZINE.BIN", "rb");
        if (tofFile == NULL) {
            printf("Error opening file '%s'.\n", "JOURNAL_MAGAZINE.BIN");
            return;
        }

        fread(&header, sizeof(tofentete), 1, tofFile);

        fseek(tofFile, sizeof(tofentete) + (blck-1) * sizeof(TblocTOF), SEEK_SET);
        fread(&tofBloc, sizeof(TblocTOF), 1, tofFile);

        printf("\nRecord found! ID: %d\n", tofBloc.tab[dep-1].id);
        printf("  Title       : %s\n", tofBloc.tab[dep-1].title);
        printf("  Author      : %s\n", tofBloc.tab[dep-1].author);
        printf("  Type        : %s\n", types[tofBloc.tab[dep-1].type-1]);
        printf("  Domain      : %s\n", domains[tofBloc.tab[dep-1].domain-1]);
        printf("  Pub Year    : %d\n", tofBloc.tab[dep-1].pub_year);
        printf("  Quantity    : %d\n", tofBloc.tab[dep-1].qty);
    }
}

/*********** Binary Search in TOF's File && Displaying the record ***********/

void searchByIdInTOF(const char *filename, int searchId) {
    int C61 = 0;
    FILE *tofFile;
    TblocTOF tofBloc;
    tofentete header;
    int found = 0;

    tofFile = fopen(filename, "rb");
    if (tofFile == NULL) {
        printf("Error opening file '%s'.\n", filename);
        return;
    }

    fread(&header, sizeof(tofentete), 1, tofFile); C61++;

    for (int i = 0; i < header.nbBloc; i++) {
        fseek(tofFile, sizeof(tofentete) + i * sizeof(TblocTOF), SEEK_SET);
        fread(&tofBloc, sizeof(TblocTOF), 1, tofFile); C61++;
        for (int j = 0; j < tofBloc.NB; j++) {
            Tenreg record = tofBloc.tab[j];

            if (record.id == searchId) {
                printf("\nRecord found! ID: %d\n", record.id);
                printf("  Title       : %s\n", record.title);
                printf("  Author      : %s\n", record.author);
                printf("  Type        : %s\n", types[record.type-1]);
                printf("  Domain      : %s\n", domains[record.domain-1]);
                printf("  Pub Year    : %d\n", record.pub_year);
                printf("  Quantity    : %d\n", record.qty);
                found = 1;
                break;
            }
        }

        if (found) {
            break;
        }
    }
    if (!found) {
        printf("No record found with ID: %d\n", searchId);
    }

    fclose(tofFile);
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C61): %10d |\n", C61);
    printf("+-----------------------------------------------+\n");
}

/*********** Displaying the blocs of TOF's File ***********/

void displayTOF(const char *filename) {
    FILE *tofFile;
    TblocTOF tofBloc;
    tofentete header;

    tofFile = fopen(filename, "rb");
    if (tofFile == NULL) {
        printf("Error");
        return;
    }

    fread(&header, sizeof(tofentete), 1, tofFile);
    printf("\n ** Number of blocks in the TOF file: %d **\n", header.nbBloc);
    printf("--- Displaying TOF records ---\n\n");

    for (int i = 0; i < header.nbBloc; i++) {
    fseek(tofFile, sizeof(tofentete) + i * sizeof(TblocTOF), SEEK_SET);
        fread(&tofBloc, sizeof(TblocTOF), 1, tofFile);

        printf("Bloc n%d\n", i+1);

        for (int j = 0; j < tofBloc.NB; j++) {
            Tenreg record = tofBloc.tab[j];
            Textecolor(9);
            printf("\nRecord %d (ID: %d):\n", j + 1, record.id);
            Textecolor(7);
            printf("  Title       : %s\n", record.title);
            printf("  Author      : %s\n", record.author);
            printf("  Type        : %s\n", types[record.type-1]); // Add a lookup for type if needed
            printf("  Domain      : %s\n", domains[record.domain-1]); // Add a lookup for domain if needed
            printf("  Publication Year: %d\n", record.pub_year);
            printf("  Quantity    : %d\n", record.qty);
            printf("---------------------------------------------------------\n");
        }
    }

    fclose(tofFile);
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C73b): %d |\n", header.nbBloc);
    printf("+-----------------------------------------------+\n");
}

/*********** Display a given bloc in TOF ***********/

void displayblock_tof(const char *filename, int blockNumber){
    int C72b=0;
    FILE *tofFile;
    TblocTOF tofBloc;
    tofentete header;

    tofFile = fopen(filename, "rb");
    if (tofFile == NULL) {
        printf("Error");
        return;
    }

    fread(&header, sizeof(tofentete), 1, tofFile); C72b++;
    if (blockNumber> header.nbBloc){printf("There are just %d blocks in the file", header.nbBloc);}
    else {
        printf("--- Displaying block n%d in the TOF file ---\n", blockNumber);

        fseek(tofFile, sizeof(tofentete) + (blockNumber-1) * sizeof(TblocTOF), SEEK_SET);
            fread(&tofBloc, sizeof(TblocTOF), 1, tofFile);
            C72b++;


            for (int j = 0; j < tofBloc.NB; j++) {
                Tenreg record = tofBloc.tab[j];
                printf("\nRecord %d (ID: %d):\n", j + 1, record.id);
                printf("  Title       : %s\n", record.title);
                printf("  Author      : %s\n", record.author);
                printf("  Type        : %s\n", types[record.type-1]);
                printf("  Domain      : %s\n", domains[record.domain-1]);
                printf("  Publication Year: %d\n", record.pub_year);
                printf("  Quantity    : %d\n", record.qty);
                printf("---------------------------------------------------------\n");
            }

        fclose(tofFile);
        printf("+-----------------------------------------------+\n");
        printf("| Total readbloc/writebloc calls (LE COUT C72b): %d |\n", C72b);
        printf("+-----------------------------------------------+\n");
    }
}

/*********** Display a given bloc in LNOF ***********/

void displayBlock(const char *filename, int blockNumber) {
    int C72a=0;
    FILE *file;
    Tbloc bloc;
    LnOF library;

    file = fopen(filename, "rb");
    if (file == NULL) {
        printf("Error\n", filename);
        return;
    }

    open(&library, filename, 'A'); C72a++;

    int currentBlock = library.entete.tete;
    int currentIndex = 1;

    while (currentBlock != -1 && currentIndex < blockNumber) {
        readbloc(&library, currentBlock, &bloc);
        C72a++;
        currentBlock = bloc.suivant;
        currentIndex++;
    }

    if (currentIndex == blockNumber) {
        printf("\nDisplaying Block %d from '%s'...\n", blockNumber-1, filename);
        printf("---------------------------------------------------------\n");
        for (int i = 0; i < bloc.NB; i++) {
            Tenreg record = bloc.tab[i];
            if (record.qty != 0) {
                printf("\nRecord %d (ID: %d):\n", i + 1, record.id);
                printf("  Title       : %s\n", record.title);
                printf("  Author      : %s\n", record.author);
                printf("  Type        : %s\n", types[record.type - 1]);
                printf("  Domain      : %s\n", domains[record.domain - 1]);
                printf("  Pub Year    : %d\n", record.pub_year);
                printf("  Quantity    : %d\n", record.qty);
                printf("---------------------------------------------------------\n");
            }
        }
    } else {
        printf("Block number %d not found.\n", blockNumber-1);
    }

    fclose(file);
    close(&library); C72a++;
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C72a): %d |\n", C72a);
    printf("+-----------------------------------------------+\n");
}

/*********** Displaying file's stats ( Creation date, Last access time, Last modification time ) ***********/

void displayFileStats(const char *filename) {
    HANDLE hFile = CreateFile(filename, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("\n");
        return;
    }

    FILETIME creationTime, lastAccessTime, lastWriteTime;
    SYSTEMTIME creationSystemTime, lastAccessSystemTime, lastWriteSystemTime;

    if (GetFileTime(hFile, &creationTime, &lastAccessTime, &lastWriteTime)) {
        FileTimeToSystemTime(&creationTime, &creationSystemTime);
        FileTimeToSystemTime(&lastAccessTime, &lastAccessSystemTime);
        FileTimeToSystemTime(&lastWriteTime, &lastWriteSystemTime);

        printf("\n--- File Stats ---\n");
        printf("File creation time    : %02d/%02d/%d %02d:%02d:%02d\n",
               creationSystemTime.wMonth, creationSystemTime.wDay, creationSystemTime.wYear,
               creationSystemTime.wHour, creationSystemTime.wMinute, creationSystemTime.wSecond);

        printf("Last access time      : %02d/%02d/%d %02d:%02d:%02d\n",
               lastAccessSystemTime.wMonth, lastAccessSystemTime.wDay, lastAccessSystemTime.wYear,
               lastAccessSystemTime.wHour, lastAccessSystemTime.wMinute, lastAccessSystemTime.wSecond);

        printf("Last modification time : %02d/%02d/%d %02d:%02d:%02d\n",
               lastWriteSystemTime.wMonth, lastWriteSystemTime.wDay, lastWriteSystemTime.wYear,
               lastWriteSystemTime.wHour, lastWriteSystemTime.wMinute, lastWriteSystemTime.wSecond);
    } else {
        printf("Error retrieving file times\n");
    }

    CloseHandle(hFile);
}
/*********** Displaying LNOF File stats + header ( Head , Tail ) ***********/

void displayTentete(const char *filename) {
    int C71a=0;
    FILE *file;
    Tentete header;
    file = fopen(filename, "rb");
    if (file == NULL) {
        printf("Error .\n");
        return;
    }
    fread(&header, sizeof(Tentete), 1, file); C71a++;
    printf("\n--- LnOF File Header ---\n");
    printf("Head (tete)        : %d\n", header.tete);
    printf("Tail (queue)       : %d\n", header.queue);
    fclose(file);
             displayFileStats(filename);
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C71a): %d |\n", C71a);
    printf("+-----------------------------------------------+\n");

}
/*********** Displaying TOF File stats + header ( Number of blocs ) ***********/

void displaytofentete(const char *filename) {
    int C71b;
    FILE *file;
    tofentete header;
    file = fopen(filename, "rb");
    if (file == NULL) {
        printf("File not created yet!\n");
        return;
    }

    fread(&header, sizeof(tofentete), 1, file); C71b++;
    printf("\n--- TOF File Header ---\n");
    printf("Number of blocks (nbBloc) : %d\n", header.nbBloc);
    fclose(file);

    displayFileStats(filename);
    printf("+-----------------------------------------------+\n");
    printf("| Total readbloc/writebloc calls (LE COUT C71b): %d |\n", C71b);
    printf("+-----------------------------------------------+\n");
}
